# 形式语言与自动机
## lecture02
---

#### 第1页内容
*来源: 第1页*

第 二 讲 上下文无关文法与上下文无关语言

##### 关键点

- 要点: 第1页内容 第 二 讲 上下文无关文法与上下文无关语言

#### 第2页内容
*来源: 第2页*

终结符的集合 一个上下文无关文法 CFG (context-free grammars) 是一个四元组 ```G = (V, T, P , S )```. 上下文无关文法的形式定义 非终结符的集合 产生式的集合 开始符号满足 VT= SV 产生式形如 A   , 其中 AV,  (VT)*上下文无关文法的基本概念

##### 关键点

- 文法定义: G = (V, T, P , S )

#### 第3页内容
*来源: 第3页*

用于推理字符串是否属于文法所定义的语言 一种是自下而上的方法，称为递归推理（recursive inference），递归推理的过程习称为归约；另一种 是自上而下的方法，称为推导（derivation） 归约过程 将产生式右部（body）形式的符号串替换为产生 式左部（head）的符号 推导过程 将产生式左部的符号替换为产生式右部的符号串归约与推导

##### 关键点

- 要点: 第3页内容 用于推理字符串是否属于文法所定义的语言 一种是自下而上的方法，称为递归推理（recursive inference），递归推理的过程习称为归约；另一种 是自上而下的方法，称为推导（derivation） 归约过程 将产生式右部（body）形式的符号串替换为产生 式左部（head）的符号 推导过程 将产生式左部的符号替换为产生式右部的符号串归约与推导

#### 第4页内容
*来源: 第4页*

句型 (sentential forms) 设 CFG ```G = (V, T, P , S )```，称 (VT)* 为 G 的一个句 型，当且仅当 S  . 若 S   ，则  是一个左句型（left-sentential form）; 若 S   ，则  是一个右句型（right-sentential form）. 若句型  T* ，则称  为一个句子（sentence）. lm rm 归约与推导 23举例：我想预订一个A月B日从X到Y的航班

##### 关键点

- 文法定义: G = (V, T, P , S )
💡 概念: 句型 (sentential form) - 第4页内容 句型 (sentential forms) 设 CFG G = (V, T, P , S )，称 (VT)* 为 G 的一个句 型，当且仅当 S  . 若 S   ，则  是一个左句型

#### 第16页内容
*来源: 第16页*

证明给定语言 L 是某个文法 G 的语言 - 一般步骤 if w  L then w  L(G) if w  L(G) then w  L . 对于前者，多数情况下可以归纳于 w 的长度 | w |； 对于后者，一般情况下可以归纳于推导w的步数. 上下文无关语言

##### 关键点

💡 概念: 上下文无关语言 (CFL) - | w |； 对于后者，一般情况下可以归纳于推导w的步数. 上下文无关语言

#### 第20页内容
*来源: 第20页*

证明给定语言L是某个文法G 的语言 - 举例 设 G 为上下文无关文法，其终结符集合为 {a, b}，开始 符号为S，产生式集合如下： S   aB  bA A  a  aS  bAA B  b  bS  aBB 试证明 L(G) = { w  w  {a, b}*, occur(w, a) = occur(w, b) }. 其中，对于符号 a 和串 w，occur(a, w) 表示 a 在 w 中出现的次数. - 证明思路 用互归纳法证明：对所有的 w  {a, b}*，如下三个等价式成立： 1）S * w iff occur(a，w) = occur(b，w) ； 2）A * w iff |w|>0  occur(a，w) = occur(b，w) + 1 ； 3）B * w iff |w|>0  occur(b，w) = occur(a，w) + 1 （留作思考题）上下文无关语言

##### 关键点

💡 概念: 上下文无关语言 (CFL) - (b，w) = occur(a，w) + 1 （留作思考题）上下文无关语言

#### 第21页内容
*来源: 第21页*

0 型文法 0 型文法 ```G = (V, T, P , S )``` 的产生式形如    , 其中 ,  (VT)*，但  中至少包含一个非终结 符. 能够用 0 型文法定义的语言称为0 型语言. 结论 0 型文法的能力相当于图灵机 （Turing machines）.文法与语言的Chomsky分类方法

##### 关键点

- 文法定义: G = (V, T, P , S )

#### 第22页内容
*来源: 第22页*

1 型文法 1 型文法 ```G = (V, T, P , S )``` 的产生式形如    , 满足 ，仅 S   例外，且要求 S 不得出现在任何产 生式的右部. 1 型文法也称谓上下文有关文法（context- sensitive grammars）. 能够用 1 型文法定义的语言称为 1 型语言 或 上下文有关 语言. 与1 型文法的能力相当的一种状态机模型为线性有界自 动机.文法与语言的Chomsky分类方法

##### 关键点

- 文法定义: G = (V, T, P , S )

#### 第23页内容
*来源: 第23页*

2 型文法 2 型文法 ```G = (V, T, P , S )``` 的产生式形如 A   , 其中 AV， (VT)*. 2 型文法即上下文无关文法. 能够用 2 型文法定义的语言称为2 型语言，即上下文无 关语言. 结论 与2 型文法的能力相当的一种状态机模型为下推自动机 （Pushdown Automata）.文法与语言的Chomsky分类方法

##### 关键点

- 文法定义: G = (V, T, P , S )

#### 第24页内容
*来源: 第24页*

3 型文法 3 型文法 ```G = (V, T, P , S )``` 的产生式形如 A  aB 或 A  a, 其中 A, BV，a  T  {} 3 型文法也称为正规文法. 能够用 3 型文法定义的语言称为3 型语言，即正规语言. 结论 3 型文法的能力等价于有限状态自动机.文法与语言的Chomsky分类方法

##### 关键点

- 文法定义: G = (V, T, P , S )

#### 第25页内容
*来源: 第25页*

语法分析树（parse trees） 对于 CFG ```G = (V, T, P , S )```，语法分析树是满足下列条 件的树： (1) 每个内部结点由一个非终结符标记. (2) 每个叶结点或由一个非终结符，或由一个终结符， 或由  来标记. 但标记为  时，它必是其父结点唯一 的孩子. (3) 如果一个内部结点标记为 A，而其孩子从左至右分 别标记为X1,X2, …,Xk，则 A  X1X2…Xk 是 P 中的 一个产生式. 注意：只有 k=1 时上述 Xi才有可能为， 此时结点 A 只有唯一的孩子，且 A   是P 中的一 个产生式.语法分析树

##### 关键点

- 文法定义: G = (V, T, P , S )
💡 概念: 语法分析树 (parse tree) - 第25页内容 语法分析树（parse trees） 对于 CFG G = (V, T, P , S )，语法分析树是满足下列条 件的树： (1) 每个内部结点由一个非终结符标记. (2) 每个叶结点或由一个非终结符

#### 第26页内容
*来源: 第26页*

从归约到分析树 设 CFG ```G = (V, T, P , S )```. 如果字符串 wT* 可以归约 到非终结符A，则存在一棵根结点为 A 的分析树，其 果实为 w. 证明思路 归纳于从 w 归约到 A 的步数. 基础 步数为 1. 一定有产生式 A  w . 存在右上图所示 的分析树. 归纳 设步数大于 1，且最后一 步归约使用了产生式 A  X1X2…Xk . 存在右下图所示的分析树.wA X1 X2 Xk w1 w2 wk… …A归约、推导与分析树之间关系

##### 关键点

- 文法定义: G = (V, T, P , S )

#### 第27页内容
*来源: 第27页*

- 证明思路 归纳于分析树的高度来证明 A  w.lm 基础 高度为 1. 分析树一定如 右图所示，必定有产生式 A  w. 因此， A  w.lm 从分析树到最左推导 wA X1 X2 Xk w1 w2 wk… …A lm归纳 高度大于 1 的分析树一定如 右下图所示，必定有产生式 A  X1X2…Xk . 存在w1, w2, …,wk，wi 是Xi子树的果 实或 wi =Xi （1i k），且 w = w1w2…wk， 由归纳假设， Xi wi（1i k）. 在此基础上易证得 A  w.lm 归约、推导与分析树之间关系

##### 关键点

💡 概念: 归约 (reduction) - （1i k）. 在此基础上易证得 A  w.lm 归约、推导与分析树之间关系

#### 第28页内容
*来源: 第28页*

基础 步数为 1. 一定有产生式 A  w . w 可以归约到 A. 从推导到归约 设 CFG ```G = (V, T, P , S )```. 如果对于非终结符 A 和字符 串 wT* ， A  w，则 w 可以归约到 A. 证明思路 归纳于推导 A  w 的步数. 归纳 设步数大于 1，第一步使用了产生式A  X1X2…Xk . 该推导形如 A  X1X2…Xk  w . 可以将 w 分成 w = w1w2…wk，其中 (a) 若 Xi 为终结符，则 wi = Xi. (b) 若 Xi 为非终结符，则 Xi  wi. 由归纳假设， wi 可以归约到 Xi . 这样，wi 或者为Xi，或者可以归约到 Xi ，使用产生 式A  X1X2…Xk ，得出w 可以归约到 A.  归约、推导与分析树之间关系

##### 关键点

- 文法定义: G = (V, T, P , S )
💡 概念: 归约 (reduction) - 基础 步数为 1. 一定有产生式 A  w . w 可以归约到 A. 从推导到归约 设 CFG G = (V, T, P , S ). 如果对于非终结符 A 和字符 串 wT* ， A  w，则 w 可以归约到 A. 证明思路 归纳...

#### 第29页内容
*来源: 第29页*

文法的二义性 (1) E  EOE (2) E  (E) (3) E  v (4) E  d (5) O ＋ (6) O  - 二义文法（ambiguous grammars）举例 考虑右下文 法，对于终结符串 v ＋ v  d，存在两棵不同的分析树，它 们的根结点都为开始符号 E ，果实都为v ＋ v  d . E EO E OEE d  v+ v E EO E OEE d  v + v文法和语言中的二义性

##### 关键点

- 要点: 第29页内容 文法的二义性 (1) E  EOE (2) E  (E) (3) E  v (4) E  d (5) O ＋ (6) O  - 二义文法（ambiguous grammars）举例 考虑右下文 法，对于终结符串 v ＋ v  d，存在两棵不同的分析树，它 们的根结点都为开始符号 E ，果实都为v ＋ v  d . E EO E OEE d  v+ v E EO E

#### 第30页内容
*来源: 第30页*

- 二义文法概念 CFG ```G = (V, T, P , S )``` 为二义的，如 果对某个 w T*，存在两棵不同的分析树，它们的根结点 都为开始符号 S ，果实都为 w . 如果对每一 w T*，至多 存在一棵这样的分析树，则G 为无二义的. - 二义性的判定 一个 CFG 是否为二义的问题是不可判 定的，即不存在解决该问题的算法. (theorem9.20) - 消除二义性 将会看到，没有通用的办法可以消除文法 的二义性. 在实践中，对于特定的文法，通常可以找到消 除二义性的办法.文法和语言中的二义性 文法的二义性

##### 关键点

- 文法定义: G = (V, T, P , S )

#### 第31页内容
*来源: 第31页*

文法二义性的另一种定义 - 定义 CFG ```G = (V, T, P , S )``` 为二义的，如果存在某个 w T*， 存在两个不同的从开始符号S 到 w 的最左推导. 该定义源于如下结论： - 结论 对 CFG ```G = (V, T, P , S )``` 和 w T*，w 具有两棵 不同的分析树，当且仅当存在两个不同的从开始符号 S 到 w 的最左推导. 证明思路 从不同的分析树可构造不同的最左推导；反 之，从不同的最左推导可构造不同的分析树. - 有时方便证明文法的无二义性 例如，练习5.4.7.文法和语言中的二义性

##### 关键点

- 文法定义: G = (V, T, P , S )

#### 第32页内容
*来源: 第32页*

语言中的二义性 - 如果上下文无关语言 L 的所有文法都是二义的，则称 L 是固有二义的（inherently ambiguous） - 举例 上下文无关语言 L = {anbncmdm n1,m 1} {anbmcmdn n1,m 1} 是固有二义的（m=n时）. 以下是 L 的一个 CFG S  ABC A  aAbab B  cBdcd C  aCdaDd D  bDcbc - 推论 没有通用的办法可以消除文法的二义性.文法和语言中的二义性

##### 关键点

💡 概念: 上下文无关语言 (CFL) - 第32页内容 语言中的二义性 - 如果上下文无关语言 L 的所有文法都是二义的，则称 L 是固有二义的（inherently ambiguous） - 举例 上下文无关语言 L = {anbncmdm n1,m 1} {anbmc

#### 第33页内容
*来源: 第33页*

无二义文法的设计 请给出下列语言 L 的一个无二义文法： L = { anbm | m  n  0} 文法和语言中的二义性

##### 关键点

- 要点: 第33页内容 无二义文法的设计 请给出下列语言 L 的一个无二义文法： L = { anbm | m  n  0} 文法和语言中的二义性

#### 第34页内容
*来源: 第34页*

文法和语言中的二义性 - 对于右上图的文法，采用 算符优先级联方法将其变 换为左下图的文法，对于 该文法，串 v ＋ v  d 存在 唯一的分析树. E  E A E  T T  T M T  ( E )  v  d A  ＋ M   E  EOE  (E)  v  d O ＋   TTEE d  v+ T T vE A M 消除二义性的几种文法变换方法

##### 关键点

- 要点: 第34页内容 文法和语言中的二义性 - 对于右上图的文法，采用 算符优先级联方法将其变 换为左下图的文法，对于 该文法，串 v ＋ v  d 存在 唯一的分析树. E  E A E  T T  T M T  ( E )  v  d A  ＋ M   E  EOE  (E)  v  d O ＋   TTEE d  v+ T T vE A M 消除二义性的几种文法变

#### 第35页内容
*来源: 第35页*

文法和语言中的二义性 - 右上图的文法仍然是二义 文法，串 v ＋ v ＋ d 存在 不同的分析树（下图）.E  E A E  T T  T M T  ( E )  v  d A  ＋ M   E EA E AEE + E EA E AEE d ++ +T vT vT T v T v dT 消除二义性的几种文法变换方法

##### 关键点

- 要点: 第35页内容 文法和语言中的二义性 - 右上图的文法仍然是二义 文法，串 v ＋ v ＋ d 存在 不同的分析树（下图）.E  E A E  T T  T M T  ( E )  v  d A  ＋ M   E EA E AEE + E EA E AEE d ++ +T vT vT T v T v dT 消除二义性的几种文法变换方法

#### 第36页内容
*来源: 第36页*

文法和语言中的二义性 - 采用左结合方法将右上 图的文法变换为左下图， 串 v ＋ v ＋ d 存在唯一的 分析树（右下图）. E  E A T  T T  T M F F F  ( E )  v  d A  ＋ M   E  E A E  T T  T M T  ( E )  v  d A  ＋ M   EE +T dF T E vF T vFA +A 消除二义性的几种文法变换方法

##### 关键点

- 要点: 第36页内容 文法和语言中的二义性 - 采用左结合方法将右上 图的文法变换为左下图， 串 v ＋ v ＋ d 存在唯一的 分析树（右下图）. E  E A T  T T  T M F F F  ( E )  v  d A  ＋ M   E  E A E  T T  T M T  ( E )  v  d A  ＋ M   EE +T dF T E vF T vF

#### 第37页内容
*来源: 第37页*

文法和语言中的二义性 - 悬挂else二义性 S    i S  i S e S i i e S e i S iS S S i e S i   S  S 消除二义性的几种文法变换方法 

##### 关键点

- 要点: 第37页内容 文法和语言中的二义性 - 悬挂else二义性 S    i S  i S e S i i e S e i S iS S S i e S i   S  S 消除二义性的几种文法变换方法 

#### 第38页内容
*来源: 第38页*

文法和语言中的二义性 - 采用最近嵌套匹配方法 消除悬挂 else 二义性S    i S  i S e S S    i S  i M e S M    i M e M 将右上部的文法变换为 下面的文法 串 i i e 存在唯一的 分析树（右图）S S i  e i M S  消除二义性的几种文法变换方法

##### 关键点

- 要点: 第38页内容 文法和语言中的二义性 - 采用最近嵌套匹配方法 消除悬挂 else 二义性S    i S  i S e S S    i S  i M e S M    i M e M 将右上部的文法变换为 下面的文法 串 i i e 存在唯一的 分析树（右图）S S i  e i M S  消除二义性的几种文法变换方法

#### 第39页内容
*来源: 第39页*

第 三 讲 正规表达式与正规语言

##### 关键点

- 要点: 第39页内容 第 三 讲 正规表达式与正规语言

#### 第40页内容
*来源: 第40页*

正规表达式 - L+ = LL* = L*L - L? =  + L - Ln = LLn-1 (n>0) L0 =  正规表达式的几个派生运算符

##### 关键点

- 要点: 第40页内容 正规表达式 - L+ = LL* = L*L - L? =  + L - Ln = LLn-1 (n>0) L0 =  正规表达式的几个派生运算符

#### 第41页内容
*来源: 第41页*

交换律（commutativity）和结合律 （associativeity） - L+M = M+L - (L+M)+N = L+(M+N) - (LM)N = L(MN) 幺元（identities）和零元（annihilators） -  + L = L +  = L - L = L = L - L = L = 正规表达式的代数定律

##### 关键点

- 要点: 第41页内容 交换律（commutativity）和结合律 （associativeity） - L+M = M+L - (L+M)+N = L+(M+N) - (LM)N = L(MN) 幺元（identities）和零元（annihilators） -  + L = L +  = L - L = L = L - L = L = 正规表达式的代数定律

#### 第42页内容
*来源: 第42页*

分配律（distributive law） - L(M+N) = LM+LN - (M+N)L = ML+NL 等幂律（idempotent law） - L + L = L -证明：集合证明的方法正规表达式的代数定律

##### 关键点

- 要点: 第42页内容 分配律（distributive law） - L(M+N) = LM+LN - (M+N)L = ML+NL 等幂律（idempotent law） - L + L = L -证明：集合证明的方法正规表达式的代数定律

#### 第43页内容
*来源: 第43页*

与闭包相关的定律 - (L*)* = L* - * =  - * =  - L+ = LL* = L*L （ L+的定义） - L* = L+ +  与任选运算相关的定律 - L? =  + L （L?的定义）正规表达式的代数定律

##### 关键点

- 要点: 第43页内容 与闭包相关的定律 - (L*)* = L* - * =  - * =  - L+ = LL* = L*L （ L+的定义） - L* = L+ +  与任选运算相关的定律 - L? =  + L （L?的定义）正规表达式的代数定律

#### 第54页内容
*来源: 第54页*

代数定律的具体化 - 具体化：将正规表达式中的每个变量用单个符号替换. - 一般化：将具体表达式中的单个符号用变量表示. - 结论：正规表达式的一般形式所代表的任何语言与其对 应的具体表达式的语言之间可以建立特定的对应关系. - 应用 用于发现和测试关于正规表达式的定律正规表达式的代数定律

##### 关键点

- 要点: 第54页内容 代数定律的具体化 - 具体化：将正规表达式中的每个变量用单个符号替换. - 一般化：将具体表达式中的单个符号用变量表示. - 结论：正规表达式的一般形式所代表的任何语言与其对 应的具体表达式的语言之间可以建立特定的对应关系. - 应用 用于发现和测试关于正规表达式的定律正规表达式的代数定律

#### 第56页内容
*来源: 第56页*

- 举例: 正规表达式 S*M 对应的一个具体表达式为 a*b . 任取S和M的一个实例，比如设 S={01,10}，M=L(2*). 则有: 任一 w  L(S*M)={01,10}* L(2*), 可以写成 w1w2…wk 的形式，wi 是S或M中的串，且有 c1c2…ckL(a*b) (另一方面类似). 其中，若 wi 是 S中的串，则有ci = a ，否则 ci = b. （注：默认的字母表包含了所涉及到的所有非变 量符号。前述定理和后续证明皆视如此。） 代数定律的具体化正规表达式的代数定律

##### 关键点

- 要点: 第56页内容 - 举例: 正规表达式 S*M 对应的一个具体表达式为 a*b . 任取S和M的一个实例，比如设 S={01,10}，M=L(2*). 则有: 任一 w  L(S*M)={01,10}* L(2*), 可以写成 w1w2…wk 的形式，wi 是S或M中的串，且有 c1c2…ckL(a*b) (另一方面类似). 其中，若 wi 是 S中的串，则有ci = a ，否则 ci = b.

#### 第57页内容
*来源: 第57页*

-（上述定理的）证明思路: （选讲） 归纳于正规表达式 E 的结构. (仅证一方面) 基础：若 E 为, , a，显然有 E = C, 定理成立; 若 E 为L，将唯一的变量 L 替换为符号 c，则 其具体表达式为 c. L的任何一个实例语言中的 串w，对应表达式 c 的语言L(c)中的串c. （接下页） 代数定律的具体化正规表达式的代数定律

##### 关键点

- 要点: 第57页内容 -（上述定理的）证明思路: （选讲） 归纳于正规表达式 E 的结构. (仅证一方面) 基础：若 E 为, , a，显然有 E = C, 定理成立; 若 E 为L，将唯一的变量 L 替换为符号 c，则 其具体表达式为 c. L的任何一个实例语言中的 串w，对应表达式 c 的语言L(c)中的串c. （接下页） 代数定律的具体化正规表达式的代数定律

#### 第58页内容
*来源: 第58页*

归纳：若 E=E1E2，E1中的变量为 L1, L2, …, Lm , E2中的变 量为 L1’, L2’, …, Ln’ ,可能有交叉. 分别用a1, a2, …, am, a1’, a2’, …, an’ 替换它们（也可能有交叉），则E具体化为 C ， E1和E2分别具体化为C1和C2，并且C = C1C2. 任意取定上述各变量的实例语言. 设任何wL(E)，则存在 w1L(E1) 和w2L(E2)，且满足w = w1w2. 由归纳假设，w1 可写成 s1s2…sk 的形式，其中si 是某一语言Sj i (1  ji  m) 中的串，并且aj1aj2…ajk属于语言L(C1)；同样，w2可写成 t1t2…th 的形式，其中ti 是某一语言Sli’ (1  li  n)中的串， 并且al1’ al2’ …alh’属于语言L(C2). 这样，w可写成 w = s1s2…sk t1t2…th 的形式，并且有aj1aj2…ajk al1’ al2’ …alh’属 于语言L (C). 对于E=E1+E2 和 E=E1* 的情形，可以类似证明. 代数定律的具体化 （接上页证明）正规表达式的代数定律

##### 关键点

- 要点: 第58页内容 归纳：若 E=E1E2，E1中的变量为 L1, L2, …, Lm , E2中的变 量为 L1’, L2’, …, Ln’ ,可能有交叉. 分别用a1, a2, …, am, a1’, a2’, …, an’ 替换它们（也可能有交叉），则E具体化为 C ， E1和E2分别具体化为C1和C2，并且C = C1C2. 任意取定上述各变量的实例语言. 设任何wL(E)，则存在 w1L(

#### 第59页内容
*来源: 第59页*

- 推论: 设 E, F 为正规表达式，它们具有相同的变量集； 采用同样的替换方式，得到对应于 E, F 的具体表达式分 别为C,D. 则对 E, F 中的变量对应的所有语言，满足 L(E) = L(F) iff L(C) = L(D) 证明思路: 设E, F的变量集为L1, L2, …, Lm . 设c = c1 c2… ckL(C),其中每个ci均为单个符号. 任取 wL(E)，满足 w = w1w2…wk ，且有 if wiLj , then E 具体化为C时使用 ci替换Lj . ∵ L(E) = L(F) ，∴ wL(F). 因而，有cL(D). ∴ L(C)  L(D). 同理可证 L(D)  L(C). ∴ L(C) = L(D).  假设 L(C) = L(D) ，证明L(E) = L(F). （留作思考） 代数定律的具体化正规表达式的代数定律

##### 关键点

- 要点: 第59页内容 - 推论: 设 E, F 为正规表达式，它们具有相同的变量集； 采用同样的替换方式，得到对应于 E, F 的具体表达式分 别为C,D. 则对 E, F 中的变量对应的所有语言，满足 L(E) = L(F) iff L(C) = L(D) 证明思路: 设E, F的变量集为L1, L2, …, Lm . 设c = c1 c2… ckL(C),其中每个ci均为单个符号. 任取 wL(

#### 第60页内容
*来源: 第60页*

代数定律的具体化（应用举例） - 用于发现和测试关于正规表达式的定律. - 举例: 对于具体符号a, 容易证明 a a* = a* a, 由此可以发 现定律 L L* = L* L, 其中 L 为变量，可以实例化为任何 语言. - 举例: 若要验证定律 L(M+N) = LM+LN，只要验证，对 于具体符号a、b、c, a(b+c) = ab+ac 成立. - 举例: 若要验证 L+ML = (L+M) L 是否成立，可以验证对 于具体符号a、b, a+ba = (a+b)a 是否成立. 但后者不成 立，aa 属于 (a+b)a 代表的语言，而不属于 a+ba 代表 的语言.正规表达式的代数定律

##### 关键点

- 要点: 第60页内容 代数定律的具体化（应用举例） - 用于发现和测试关于正规表达式的定律. - 举例: 对于具体符号a, 容易证明 a a* = a* a, 由此可以发 现定律 L L* = L* L, 其中 L 为变量，可以实例化为任何 语言. - 举例: 若要验证定律 L(M+N) = LM+LN，只要验证，对 于具体符号a、b、c, a(b+c) = ab+ac 成立. - 举例: 若要验证 L+

#### 第61页内容
*来源: 第61页*

第 四 讲 有限状态自动机

##### 关键点

- 要点: 第61页内容 第 四 讲 有限状态自动机

#### 第62页内容
*来源: 第62页*

- 有限状态集 - 有限输入符号集 - 转移函数 - 一个开始状态 - 一个终态集合 一个确定有限状态自动机 DFA (deterministic finite automata) 是一个五元组 A = (Q, , , q0 , F ).  : Q    Q q0  Q F  Q确定有限自动机 确定有限自动机的形式定义

##### 关键点

- 要点: 第62页内容 - 有限状态集 - 有限输入符号集 - 转移函数 - 一个开始状态 - 一个终态集合 一个确定有限状态自动机 DFA (deterministic finite automata) 是一个五元组 A = (Q, , , q0 , F ).  : Q    Q q0  Q F  Q确定有限自动机 确定有限自动机的形式定义

#### 第69页内容
*来源: 第69页*

确定有限自动机的问题 46 根据定义，确定有限自动机的转移函数必须考 虑字母表上的所有符号转到有效的状态，使得设 计难度增加。  : Q    Q

##### 关键点

- 要点: 第69页内容 确定有限自动机的问题 46 根据定义，确定有限自动机的转移函数必须考 虑字母表上的所有符号转到有效的状态，使得设 计难度增加。  : Q    Q

#### 第70页内容
*来源: 第70页*

Startp r0, 1 0q1(1) Startp0, 1 1q r0, 1(2)非确定有限自动 机 非确定有限自动机举例

##### 关键点

- 要点: 第70页内容 Startp r0, 1 0q1(1) Startp0, 1 1q r0, 1(2)非确定有限自动 机 非确定有限自动机举例

#### 第71页内容
*来源: 第71页*

- 有限状态集 - 有限输入符号集 - 转移函数 - 一个开始状态 - 一个终态集合 一个非确定有限状态自动机 NFA nondeterministic finite automata) 是一个五元组 A = (Q, , , q0 , F ). q0  Q F  Q - 与 DFA 唯一不同之处  : Q    2Q非确定有限自动 机 非确定有限自动机的形式定义

##### 关键点

- 要点: 第71页内容 - 有限状态集 - 有限输入符号集 - 转移函数 - 一个开始状态 - 一个终态集合 一个非确定有限状态自动机 NFA nondeterministic finite automata) 是一个五元组 A = (Q, , , q0 , F ). q0  Q F  Q - 与 DFA 唯一不同之处  : Q    2Q非确定有限自动 机 非确定有限自动机的形式定义

#### 第73页内容
*来源: 第73页*

非确定有限自动 机

##### 关键点

- 要点: 第73页内容 非确定有限自动 机

#### 第75页内容
*来源: 第75页*

- 设 L 是某个 DFA D = (Q, , D , q0 , F ) 的语 言, 则存在一个 NFA N , 满足 L(N) = L(D) = L. - 证明: 定义N = (Q,,N ,q0,F ) , 其中N定义为 对q Q 和a  , 若 D (q,a) = p, 则 N (q,a) = {p}. 需要证明: 对任何w  * , D (q0 ,w) = p iff N (q0 ,w) = {p}. 归纳于 | w | 易证上述命题. DFA 和 NFA 的等价性 从 DFA 构造等价的 NFA

##### 关键点

- 要点: 第75页内容 - 设 L 是某个 DFA D = (Q, , D , q0 , F ) 的语 言, 则存在一个 NFA N , 满足 L(N) = L(D) = L. - 证明: 定义N = (Q,,N ,q0,F ) , 其中N定义为 对q Q 和a  , 若 D (q,a) = p, 则 N (q,a) = {p}. 需要证明: 对任何w  * , D (q0 ,w

#### 第76页内容
*来源: 第76页*

- 设 L 是某个 NFA N = (QN, , N , q0 , FN) 的语言, 则存 在一个 DFA D , 满足 L(D) = L(N) = L. - 证明: 定义 D = (QD, , D , {q0 }, FD ) , 其中 QD =  S  S  QN  对 S  QD 和 a   , D ( S , a ) =  N (q,a) FD = SS  QN  S  FN    需要证明: 对任何w  * , D ( {q0 } , w ) = N (q0 ,w). 归纳于 | w | 可证上述命题.q  SDFA 和 NFA 的等价性 从 NFA 构造等价的 DFA（子集构造法）

##### 关键点

- 要点: 第76页内容 - 设 L 是某个 NFA N = (QN, , N , q0 , FN) 的语言, 则存 在一个 DFA D , 满足 L(D) = L(N) = L. - 证明: 定义 D = (QD, , D , {q0 }, FD ) , 其中 QD =  S  S  QN  对 S  QD 和 a   , D ( S , a ) =  N (q,a) FD = 

#### 第78页内容
*来源: 第78页*

- 实践中, 通过子集构造法得到的 DFA 的状态 数目与原 NFA 的状态数目大体相当 - 在较坏的情况下,上述 DFA 的状态数目接近 于所有子集的数目 - 举例 由如下 NFA 构造的 DFA 的状态数目至 少为2n q0 q1 q2 qnDFA 和 NFA 的等价性 子集构造法得到的状态数

##### 关键点

- 要点: 第78页内容 - 实践中, 通过子集构造法得到的 DFA 的状态 数目与原 NFA 的状态数目大体相当 - 在较坏的情况下,上述 DFA 的状态数目接近 于所有子集的数目 - 举例 由如下 NFA 构造的 DFA 的状态数目至 少为2n q0 q1 q2 qnDFA 和 NFA 的等价性 子集构造法得到的状态数

#### 第79页内容
*来源: 第79页*

- 上页例子的证明要点，采用反证法 假设由此 NFA 构造的 DFA 的状态数目少于2n Start0, 1 1 0, 1 0, 1 0, 1...... q0 q1 q2 qn 考虑长度为 n 的 0,1 串共有 2n 个，所以存在两个不同 的串a1a2…an 和 b1b2…bn 做为该 DFA 的输入，可以 到达同一状态 q.（by Pigeonhole Principle） 若a1b1，则 q 既是终态又是非终态，矛盾； 一般情况，若 ak bk ，设a1a2…an00…0（k-1 个 0） 或b1b2…bn00…0（k-1 个 0）作为输入串时该 DFA 到达状态p, 则 p 既是终态又是非终态，矛盾。DFA 和 NFA 的等价性 子集构造法得到的状态数

##### 关键点

- 要点: 第79页内容 - 上页例子的证明要点，采用反证法 假设由此 NFA 构造的 DFA 的状态数目少于2n Start0, 1 1 0, 1 0, 1 0, 1...... q0 q1 q2 qn 考虑长度为 n 的 0,1 串共有 2n 个，所以存在两个不同 的串a1a2…an 和 b1b2…bn 做为该 DFA 的输入，可以 到达同一状态 q.（by Pigeonhole Principle） 若

#### 第80页内容
*来源: 第80页*

举例 设计一个 NFA 用来在文本中搜索 字符串web 和ebb. 解 下图为一个满足条件的 NFA，其中  代表所有 ASCII 字符的集合. 文本搜索

##### 关键点

- 要点: 第80页内容 举例 设计一个 NFA 用来在文本中搜索 字符串web 和ebb. 解 下图为一个满足条件的 NFA，其中  代表所有 ASCII 字符的集合. 文本搜索

#### 第81页内容
*来源: 第81页*

一个  - NFA 是一个五元组 A = (Q, , , q0 , F ). - 有限状态集 - 有限输入符号集 - 转移函数 - 一个开始状态 - 一个终态集合q0  Q F  Q - 与 NFA 的不同之处  : Q （    ） 2Q带 -转移的非确定有限自动机 带 - 转移的非确定有限自动机（ - NFA） 的形式定义

##### 关键点

- 要点: 第81页内容 一个  - NFA 是一个五元组 A = (Q, , , q0 , F ). - 有限状态集 - 有限输入符号集 - 转移函数 - 一个开始状态 - 一个终态集合q0  Q F  Q - 与 NFA 的不同之处  : Q （    ） 2Q带 -转移的非确定有限自动机 带 - 转移的非确定有限自动机（ - NFA） 的形式定义

#### 第82页内容
*来源: 第82页*

Start0,1, ... ,9 .0,1, ... ,9 0,1, ... ,9 0,1, ... ,9.q1 q0 q2 q3 q5  ,+,– q4 - 状态 q 的 - 闭包，记为ECLOSE(q)，定义为从 q 经 所有的 路径可以到达的状态（包括q自身），如： ECLOSE(q0) = {q0,q1 } ECLOSE(q2) = {q2 } ECLOSE(q3) = {q3,q5 }带 -转移的非确定有限自动机  - 闭包（closure）

##### 关键点

- 要点: 第82页内容 Start0,1, ... ,9 .0,1, ... ,9 0,1, ... ,9 0,1, ... ,9.q1 q0 q2 q3 q5  ,+,– q4 - 状态 q 的 - 闭包，记为ECLOSE(q)，定义为从 q 经 所有的 路径可以到达的状态（包括q自身），如： ECLOSE(q0) = {q0,q1 } ECLOSE(q2) = {q2 } ECLOSE(q3) 

#### 第84页内容
*来源: 第84页*

Start0,1, ... ,9 .0,1, ... ,9 0,1, ... ,9 0,1, ... ,9.q1 q0 q2 q3 q5  ,+,– q4 - 举例 计算  (q0, 5.6)  (q0, ) = ECLOSE(q0) = {q0,q1 }  (q0, 5)   (q1, 5) = {q1,q4 }  (q0, 5) = ECLOSE(q1)  ECLOSE(q4) = {q1,q4 }  (q1, .)   (q4, .) = {q2,q3 }  (q0, 5.) = ECLOSE(q2)  ECLOSE(q3) = {q2,q3 ,q5 }  (q2, 6)   (q3, 6)   (q5, 6) = {q3 }  (q0, 5.6) = ECLOSE(q3) = {q3 ,q5 }带 -转移的非确定有限自动机 扩展转移函数适合于输入字符串

##### 关键点

- 要点: 第84页内容 Start0,1, ... ,9 .0,1, ... ,9 0,1, ... ,9 0,1, ... ,9.q1 q0 q2 q3 q5  ,+,– q4 - 举例 计算  (q0, 5.6)  (q0, ) = ECLOSE(q0) = {q0,q1 }  (q0, 5)   (q1, 5) = {q1,q4 }  (q0, 5) = ECLOSE(q1) 

#### 第85页内容
*来源: 第85页*

- 设 L 是某个 DFA D = (Q, , D , q0 , F ) 的语言, 则存在一个  - NFA E , 满足 L(E) = L(D) = L. - 证明: 定义 E = (Q, , E , q0 , F ) , 其中 E 定义为 对任何q Q, E (q, ) =  对任何q Q 和a  , 若 D (q,a) = p, 则 E (q,a) = {p}. 需要证明: 对任何w  * , D (q0 ,w) = p iff E (q0 ,w) = {p}. 归纳于 | w | 易证上述命题.带 -转移的非确定有限自动机 从 DFA 构造等价的 - NFA

##### 关键点

- 要点: 第85页内容 - 设 L 是某个 DFA D = (Q, , D , q0 , F ) 的语言, 则存在一个  - NFA E , 满足 L(E) = L(D) = L. - 证明: 定义 E = (Q, , E , q0 , F ) , 其中 E 定义为 对任何q Q, E (q, ) =  对任何q Q 和a  , 若 D (q,a) = p, 则 E (q,a)

#### 第86页内容
*来源: 第86页*

- 设 L 是某个  - NFA E = (QE, , E , q0 , FE) 的语言, 则 存在一个 DFA D , 满足 L(D) = L(E) = L. - 证明: 定义 D = (QD, , D , qD , FD ) , 其中 QD =  S  S  QE S = ECLOSE(S)  qD = ECLOSE(q0) FD = SS QD  S  FE    对 S  QD 和 a   , 令 S = { p1 , p2 ,  , pk }， 并设  E ( pi , a ) = { r1 , r2 ,  , rm }， 则 D ( S , a ) =  ECLOSE( rj ) . 需要证明: 对任何w  * , D (qD, w ) = E (q0 ,w). 归纳于 | w | 可证上述命题.i = 1k j = 1m带 -转移的非确定有限自动机 从  - NFA 构造等价的 DFA（修改的子集构造法）

##### 关键点

- 要点: 第86页内容 - 设 L 是某个  - NFA E = (QE, , E , q0 , FE) 的语言, 则 存在一个 DFA D , 满足 L(D) = L(E) = L. - 证明: 定义 D = (QD, , D , qD , FD ) , 其中 QD =  S  S  QE S = ECLOSE(S)  qD = ECLOSE(q0) FD = SS QD  S

#### 第87页内容
*来源: 第87页*

- 设 E = (QE, , E , q0 , FE) 是一个  - NFA , 通过修改的子 集构造法得到相应的DFA D = (QD, , D , qD, FD ), 则 对任何w  * , D (qD, w ) = E (q0 ,w). - 证明:归纳于 | w | 1 设| w | = 0, 即 w =  . 由定义知 D (qD,  ) = qD = ECLOSE(q0) = E (q0 , ). 2 设| w | = n+1, 并 w = xa, a   . 注意到| x | = n. 假设 D (qD, x ) = E(q0 , x) = { p1 , p2 ,  , pk }. i = 1k 并设  E ( pi , a ) = { r1 , r2 ,  , rm }. 则 D (qD, w ) = D ({ p1 , p2 ,  , pk } , a ) =  ECLOSE( rj ) = E (q0 , w) j = 1m带 -转移的非确定有限自动机 从  - NFA 构造等价的 DFA（修改的子集构造法）

##### 关键点

- 要点: 第87页内容 - 设 E = (QE, , E , q0 , FE) 是一个  - NFA , 通过修改的子 集构造法得到相应的DFA D = (QD, , D , qD, FD ), 则 对任何w  * , D (qD, w ) = E (q0 ,w). - 证明:归纳于 | w | 1 设| w | = 0, 即 w =  . 由定义知 D (qD,  ) = q

#### 第94页内容
*来源: 第94页*

计算状态集划分的算法— 填表法 - 填表算法（table-filling algorithm）基于如下 递归地标记可区别的状态偶对的过程: 基础 如果 p 为终态，而 q 为非终态，则 p 和 q 标记 为可区别的； 归纳 设 p 和 q 已标记为可区别的, 如果状态 r 和 s 通过某个输入符号 a 可分别转移到 p 和 q ， (r,a)=p , (s,a)=q , 则 r 和 s 也标记为可区别的；（确定）有限自动机的最小化

##### 关键点

- 要点: 第94页内容 计算状态集划分的算法— 填表法 - 填表算法（table-filling algorithm）基于如下 递归地标记可区别的状态偶对的过程: 基础 如果 p 为终态，而 q 为非终态，则 p 和 q 标记 为可区别的； 归纳 设 p 和 q 已标记为可区别的, 如果状态 r 和 s 通过某个输入符号 a 可分别转移到 p 和 q ， (r,a)=p , (s,a)=q , 则 r 

#### 第95页内容
*来源: 第95页*

- 填表算法的正确性 还需证明：如果两个状态没有被填表 算法标记，则这两个状态一定是等价的 - 证明 反证法. 假定状态 r 和s 没有被填表算法标记， 但这两个状态不是等价的，即是可区别的. 设字符串 w 可用于区别状态 r 和s，即 '(r,w) 和 '(s,w) 两个状态中，一个是终态，一个是非终态. 不 妨设前者为终态, 后者为非终态. 首先不可能有 w=, 否则, 状态 r 为终态, 而s 为非 终态，依填表算法, r 和s 第一步就被标记. 设w=ax, 并且(r,a)=p, (s,a)=q, 则p 和q 可被 x 区 别. 但同样p 和q 不可能被填表算法标记(否则, r 和s 将 被标记). 同样也有, x. 该过程不可能一直下去, 终将产生矛盾.（确定）有限自动机的最小化 计算状态集划分的算法—填表法

##### 关键点

- 要点: 第95页内容 - 填表算法的正确性 还需证明：如果两个状态没有被填表 算法标记，则这两个状态一定是等价的 - 证明 反证法. 假定状态 r 和s 没有被填表算法标记， 但这两个状态不是等价的，即是可区别的. 设字符串 w 可用于区别状态 r 和s，即 '(r,w) 和 '(s,w) 两个状态中，一个是终态，一个是非终态. 不 妨设前者为终态, 后者为非终态. 首先不可能有 w=, 否则, 状

#### 第96页内容
*来源: 第96页*

通过合并等价的状态进行 DFA 的优化 - 步骤 1. 删除所有从开始状态不可到达的状态及与其相关的边, 设所得到的 DFA 为 A = (Q, , , q0 , F ) ； 2. 使用填表算法找出所有等价的状态偶对； 3. 根据 2 的结果计算当前状态集合的划分块，每一划分 块中的状态相互之间等价，而不同划分块中的状态之 间都是可区别的. 包含状态 q 的划分块用 [q] 表示. 4. 构造与 A 等价的 DFA B = (QB, , B, [q0], FB ) , 其中 QB={ [q] | qQ}, FB = { [q] | qF}, B([q] ,a)=[ (q,a)] - 结论：对任何 w*, B([q0], w)FB, iff  (q0, w)F（确定）有限自动机的最小化

##### 关键点

- 要点: 第96页内容 通过合并等价的状态进行 DFA 的优化 - 步骤 1. 删除所有从开始状态不可到达的状态及与其相关的边, 设所得到的 DFA 为 A = (Q, , , q0 , F ) ； 2. 使用填表算法找出所有等价的状态偶对； 3. 根据 2 的结果计算当前状态集合的划分块，每一划分 块中的状态相互之间等价，而不同划分块中的状态之 间都是可区别的. 包含状态 q 的划分块用 [q] 表示

#### 第97页内容
*来源: 第97页*

最小化的 DFA - 问题 假定一个 DFA 为 A, 用上述优化步骤构造出与 A 等 价的DFA M; 那么是否存在一个状态数目比 M 还少的DFA N, 它接受的语言同 A 和 M 完全一样? 假设存在一个这样 DFA N. 现将 M 和 N 相并, 即状态、 转移规则都相并, 这里假定 M 和 N 之间没有重名的状态, 因而也没有相交的转移边, 原来的终态还是终态, 原来的两 个初态中任选一个作为新的初态. 同时还假定 M 和 N 的每 一状态都是从其相应的初态可以到达的，否则我们将去掉 不可达状态，得到状态数目更小的 DFA.（确定）有限自动机的最小化

##### 关键点

- 要点: 第97页内容 最小化的 DFA - 问题 假定一个 DFA 为 A, 用上述优化步骤构造出与 A 等 价的DFA M; 那么是否存在一个状态数目比 M 还少的DFA N, 它接受的语言同 A 和 M 完全一样? 假设存在一个这样 DFA N. 现将 M 和 N 相并, 即状态、 转移规则都相并, 这里假定 M 和 N 之间没有重名的状态, 因而也没有相交的转移边, 原来的终态还是终态, 原来的两 

#### 第98页内容
*来源: 第98页*

最小化的 DFA（确定）有限自动机的最小化

##### 关键点

- 要点: 第98页内容 最小化的 DFA（确定）有限自动机的最小化

#### 第99页内容
*来源: 第99页*

- 结论 对任何 DFA A, 用前述优化步骤构造出与 A 等价的 DFA M; 那么 M 的状态数目不多于任何语言为 L(A) 的 DFA 对 M 和 N 相并后的 DFA 运用填表算法可以得出: 1. M 和 N 的初态是不可区别的, 因为 L(M)=L(N); 2. 若 r 和 s 是不可区别的, 则对于任何输入符号, r 和 s 的后继状态之间也是不可区别的; 3. M 的任一状态至少与 N 的一个状态是不可区别的. 根据假设, N 的状态数目比 M 少, 所以 M 中必然存在 两个状态, 它们分别与 N 中的同一个状态不可区别. 根据不可区别关系的传递性，M 的这两个状态是不 可区别的, 这与 M 的构造过程矛盾.（确定）有限自动机的最小化 最小化的 DFA

##### 关键点

- 要点: 第99页内容 - 结论 对任何 DFA A, 用前述优化步骤构造出与 A 等价的 DFA M; 那么 M 的状态数目不多于任何语言为 L(A) 的 DFA 对 M 和 N 相并后的 DFA 运用填表算法可以得出: 1. M 和 N 的初态是不可区别的, 因为 L(M)=L(N); 2. 若 r 和 s 是不可区别的, 则对于任何输入符号, r 和 s 的后继状态之间也是不可区别的; 3. M 的任

#### 第100页内容
*来源: 第100页*

第 五 讲 有限状态自动机  正规表达式

##### 关键点

- 要点: 第100页内容 第 五 讲 有限状态自动机  正规表达式

#### 第101页内容
*来源: 第101页*

- 基础: 1 对于  ，构造为 3 对于 a ，构造为 a2 对于  ，构造为有限自动机与正规表达式的关系 归纳构造过程 (从正规表达式构造等价的 - NFA) （Thompson 构造法）

##### 关键点

- 要点: 第101页内容 - 基础: 1 对于  ，构造为 3 对于 a ，构造为 a2 对于  ，构造为有限自动机与正规表达式的关系 归纳构造过程 (从正规表达式构造等价的 - NFA) （Thompson 构造法）

#### 第102页内容
*来源: 第102页*

- 归纳: 1 对于 E+F ，构造为  有限自动机与正规表达式的关系 归纳构造过程 (从正规表达式构造等价的 - NFA) （Thompson 构造法）

##### 关键点

- 要点: 第102页内容 - 归纳: 1 对于 E+F ，构造为  有限自动机与正规表达式的关系 归纳构造过程 (从正规表达式构造等价的 - NFA) （Thompson 构造法）

#### 第103页内容
*来源: 第103页*

2 对于 EF ，构造为  3 对于 E* ，构造为   有限自动机与正规表达式的关系 - 归纳: 归纳构造过程 (从正规表达式构造等价的 - NFA) （Thompson 构造法）

##### 关键点

- 要点: 第103页内容 2 对于 EF ，构造为  3 对于 E* ，构造为   有限自动机与正规表达式的关系 - 归纳: 归纳构造过程 (从正规表达式构造等价的 - NFA) （Thompson 构造法）

#### 第104页内容
*来源: 第104页*

有限自动机与正规表达式的关系 08 (a) (b)(c)  

##### 关键点

- 要点: 第104页内容 有限自动机与正规表达式的关系 08 (a) (b)(c)  

#### 第105页内容
*来源: 第105页*

有限自动机与正规表达式的关系 09 (a) (b)(c)  

##### 关键点

- 要点: 第105页内容 有限自动机与正规表达式的关系 09 (a) (b)(c)  

#### 第106页内容
*来源: 第106页*

有限自动机与正规表达式的关系 10 (a) (b)(c)  

##### 关键点

- 要点: 第106页内容 有限自动机与正规表达式的关系 10 (a) (b)(c)  

#### 第107页内容
*来源: 第107页*

有限自动机与正规表达式的关系 11 (a) (b)(c)  

##### 关键点

- 要点: 第107页内容 有限自动机与正规表达式的关系 11 (a) (b)(c)  

#### 第108页内容
*来源: 第108页*

有限自动机与正规表达式的关系 12 (a) (b)(c)  

##### 关键点

- 要点: 第108页内容 有限自动机与正规表达式的关系 12 (a) (b)(c)  

#### 第109页内容
*来源: 第109页*

有限自动机与正规表达式的关系 13 (a) (b)(c)  

##### 关键点

- 要点: 第109页内容 有限自动机与正规表达式的关系 13 (a) (b)(c)  

#### 第111页内容
*来源: 第111页*

- 步骤: (1) 将 DFA D 的状态集用{1, 2, … , n}表达， 且初态为1 (2) 对所有1i, j  n, 0k n ，迭代计算R(ikj)； 这里, R(ikj) 为表示如下语言的正规表达式： w  L(R(ikj) ) iff 从 i 到 j 有一条标记为 w 的 路径, 且这条路径上除 i 和 j 之外的所有状态 的编号均不大于 k (3) 通过(2)的迭代过程，最终可计算出 R(inj)（i, j = 1, 2, … , n） (4) 将所有 R(1nj)（j 为任一终态）相“” 路径迭代法（从 DFA 构造等价的正规表达式）有限自动机与正规表达式的关系

##### 关键点

- 要点: 第111页内容 - 步骤: (1) 将 DFA D 的状态集用{1, 2, … , n}表达， 且初态为1 (2) 对所有1i, j  n, 0k n ，迭代计算R(ikj)； 这里, R(ikj) 为表示如下语言的正规表达式： w  L(R(ikj) ) iff 从 i 到 j 有一条标记为 w 的 路径, 且这条路径上除 i 和 j 之外的所有状态 的编号均不大于 k (3) 通过(

#### 第112页内容
*来源: 第112页*

计算 R(ikj) 的迭代过程 - 基础: k = 0 Case 1 ij 若不存在从 i 到 j 的弧，则R(i0j) = ； 若仅存在一条从 i 到 j 的弧，且标记为a ，则R(i0j) = a； 若存在多条从 i 到 j 的弧，且标记为a1, a2, … , am， 则 R(i0j) = a1  a2  …  am ； Case 2 i=j 若不存在从 i 到自身的圈，则R(i0j) =  ； 若存在一个从 i 到自身的圈且标记为a ，则R(i0j) =  a； 若存在多个从 i到自身的圈，且标记为a1, a2, … , am ， 则 R(i0j) =   a1  a2  …  am ；有限自动机与正规表达式的关系

##### 关键点

- 要点: 第112页内容 计算 R(ikj) 的迭代过程 - 基础: k = 0 Case 1 ij 若不存在从 i 到 j 的弧，则R(i0j) = ； 若仅存在一条从 i 到 j 的弧，且标记为a ，则R(i0j) = a； 若存在多条从 i 到 j 的弧，且标记为a1, a2, … , am， 则 R(i0j) = a1  a2  …  am ； Case 2 i=j 若不存在从 i 到自身

#### 第113页内容
*来源: 第113页*

计算 R(ikj) 的迭代过程 - 归纳: 假设 R( ki-j1 ) （i, j = 1, 2, … , n）已经求出. 则迭代 公式为 R(ikj) = R( ki-j1 )  R( ki-k1 ) (R( kk-k1 ) )* R( kk-j1 ) Case 1 路径不经过 k . 此时，标记该路径的字符串属 于 L( R( ki-j1 ) ); Case 2 路径经过 k至少一次. 此时，标记该路径的字符 串属于 L(R( ki-k1 ) (R( kk-k1 ) )* R( kk-j1 ) ). 如下图所示：分析: 考虑从 i 到 j 的路径（除 i 和 j 之外的所有状态的 编号不大于 k ） i k k...k j R( ki-k1 ) (R( kk-k1 ) )* R( kk-j1 )有限自动机与正规表达式的关系

##### 关键点

- 要点: 第113页内容 计算 R(ikj) 的迭代过程 - 归纳: 假设 R( ki-j1 ) （i, j = 1, 2, … , n）已经求出. 则迭代 公式为 R(ikj) = R( ki-j1 )  R( ki-k1 ) (R( kk-k1 ) )* R( kk-j1 ) Case 1 路径不经过 k . 此时，标记该路径的字符串属 于 L( R( ki-j1 ) ); Case 2 路径经过 k

#### 第114页内容
*来源: 第114页*

路径迭代法举例 R(101) R(102) R(201) R(202)  1   0  10 有限自动机与正规表达式的关系

##### 关键点

- 要点: 第114页内容 路径迭代法举例 R(101) R(102) R(201) R(202)  1   0  10 有限自动机与正规表达式的关系

#### 第115页内容
*来源: 第115页*

1 20 Start1 0,1 R(i1j) = R(i0j)  R(i01) (R(101) )* R(10j)化简 R(111) R(112) R(211) R(212)直接替换  1 ( 1)( 1)*( 1 ) 0( 1)( 1)*0  ( 1)*( 1 )  0 1( 1)*01* 1*0   0 1R(101) R(102) R(201) R(202)  1   0  10 有限自动机与正规表达式的关系 路径迭代法举例

##### 关键点

- 要点: 第115页内容 1 20 Start1 0,1 R(i1j) = R(i0j)  R(i01) (R(101) )* R(10j)化简 R(111) R(112) R(211) R(212)直接替换  1 ( 1)( 1)*( 1 ) 0( 1)( 1)*0  ( 1)*( 1 )  0 1( 1)*01* 1*0   0 1R(1

#### 第116页内容
*来源: 第116页*

1 20 Start1 0,1 化简 R(121) R(122) R(221) R(222)直接替换 R(i2j) = R(i1j)  R(i12) (R(212) )* R(21j)1*1*0( 0 1)*  1*01*0( 0 1)*( 0 1)  ( 0 1)( 0 1)*   0 1( 0 1)( 0 1)*( 0 1)1* 1*0(0  1)*  (0 1)*R(111) R(112) R(211) R(212)   0  11* 1*0有限自动机与正规表达式的关系 路径迭代法举例

##### 关键点

- 要点: 第116页内容 1 20 Start1 0,1 化简 R(121) R(122) R(221) R(222)直接替换 R(i2j) = R(i1j)  R(i12) (R(212) )* R(21j)1*1*0( 0 1)*  1*01*0( 0 1)*( 0 1)  ( 0 1)( 0 1)*   0 1( 0 1)( 0 1)*(

#### 第117页内容
*来源: 第117页*

1 20 Start1 0,1 结果: 初态为1, 终态只有一个 2 ，所以， 一个 与上图的 DFA 等价的正规表达式为 R(122) = 1*0(0  1)*有限自动机与正规表达式的关系 路径迭代法举例

##### 关键点

- 要点: 第117页内容 1 20 Start1 0,1 结果: 初态为1, 终态只有一个 2 ，所以， 一个 与上图的 DFA 等价的正规表达式为 R(122) = 1*0(0  1)*有限自动机与正规表达式的关系 路径迭代法举例

#### 第118页内容
*来源: 第118页*

- 思路: (1) 扩展自动机的概念，允许正规表达式作为转移弧 的标记. 这样，就有可能在消去某一中间状态时， 保证自动机能够接受的字符串集合保持不变. (2) 在消去某一中间状态时，与其相关的转移弧也 将同时消去，所造成的影响将通过修改从每一个 前趋状态到每一个后继状态的转移弧标记来弥补. 以下分别介绍中间状态的消去与正规表达式构造过程.有限自动机与正规表达式的关系 状态消去法（从 DFA 构造等价的正规表达式）

##### 关键点

- 要点: 第118页内容 - 思路: (1) 扩展自动机的概念，允许正规表达式作为转移弧 的标记. 这样，就有可能在消去某一中间状态时， 保证自动机能够接受的字符串集合保持不变. (2) 在消去某一中间状态时，与其相关的转移弧也 将同时消去，所造成的影响将通过修改从每一个 前趋状态到每一个后继状态的转移弧标记来弥补. 以下分别介绍中间状态的消去与正规表达式构造过程.有限自动机与正规表达式的关系 状态消去法（

#### 第119页内容
*来源: 第119页*

- 步骤: （假设自动机已转化为扩展的形式） (1) 对每一终态q，依次消去除 q 和初态 q0 之外的其它状态; (2) 若q q0，最终可得到一般形式如下左图两状态自动机， 该自动机对应的正规表达式可表示为 ( R+SU*T )*SU*. (3) 若q= q0，最终可得到如下右图的自动机，它对应的正规 表达式可以表示为 R*. (4) 最终的正规表达式为每一终态对应的 正规表达式之和（并）.有限自动机与正规表达式的关系 状态消去法（从 DFA 构造等价的正规表达式）

##### 关键点

- 要点: 第119页内容 - 步骤: （假设自动机已转化为扩展的形式） (1) 对每一终态q，依次消去除 q 和初态 q0 之外的其它状态; (2) 若q q0，最终可得到一般形式如下左图两状态自动机， 该自动机对应的正规表达式可表示为 ( R+SU*T )*SU*. (3) 若q= q0，最终可得到如下右图的自动机，它对应的正规 表达式可以表示为 R*. (4) 最终的正规表达式为每一终态对应的 正规表

#### 第121页内容
*来源: 第121页*

从 DFA 构造 NFA - 回顾：设 DFA D = (Q, , D , q0 , F ), 构造 NFA N = (Q, , N , q0 , FN ) , 其中 N 定义为 对q Q 和a  , 若 D (q,a) = p, 则 N (q,a) = {p}. - 设 |Q|=n, 该构造过程复杂度为O(n), 即线性时间.几个转换算法的复杂度（选讲）

##### 关键点

- 要点: 第121页内容 从 DFA 构造 NFA - 回顾：设 DFA D = (Q, , D , q0 , F ), 构造 NFA N = (Q, , N , q0 , FN ) , 其中 N 定义为 对q Q 和a  , 若 D (q,a) = p, 则 N (q,a) = {p}. - 设 |Q|=n, 该构造过程复杂度为O(n), 即线性时间.几个转换算法的复杂度（选讲）

#### 第122页内容
*来源: 第122页*

- 回顾：设 NFA N = (Q, , N , q0 , F ) , 构造 D = (QD, , D , {q0 }, FD ) , 其中 QD =  S  S  Q  对 S  QD 和 a   , D ( S , a ) =  N (q,a) . FD = SS  Q  S  F    - 设 | Q |=n, 该构造过程复杂度为O(n22n). 但实际运行时 间的上界可以是O(n2s)，其中 s 为 DFA 实际状态数。q  S 从 NFA 构造 DFA几个转换算法的复杂度（选讲）

##### 关键点

- 要点: 第122页内容 - 回顾：设 NFA N = (Q, , N , q0 , F ) , 构造 D = (QD, , D , {q0 }, FD ) , 其中 QD =  S  S  Q  对 S  QD 和 a   , D ( S , a ) =  N (q,a) . FD = SS  Q  S  F    - 设 | Q |=n, 该构造过程复杂度为O

#### 第123页内容
*来源: 第123页*

从 DFA 构造  - NFA - 回顾：设 DFA D = (Q, , D , q0 , F ) , 构造 E = (Q, , E , q0 , FE ) , 其中 E 定义为 对任何q Q, E (q, ) =  对任何q Q 和a  , 若 D (q,a) = p, 则 N (q,a) = {p} - 设 |Q|=n, 该构造过程复杂度为O(n).几个转换算法的复杂度（选讲）

##### 关键点

- 要点: 第123页内容 从 DFA 构造  - NFA - 回顾：设 DFA D = (Q, , D , q0 , F ) , 构造 E = (Q, , E , q0 , FE ) , 其中 E 定义为 对任何q Q, E (q, ) =  对任何q Q 和a  , 若 D (q,a) = p, 则 N (q,a) = {p} - 设 |Q|=n, 该构造过程复杂度为O(n)

#### 第124页内容
*来源: 第124页*

从  - NFA 构造 DFA - 回顾：设  - NFA E = (QE, , E , q0 , FE) , 构造 D = (QD, , D , qD , FD ) , 其中 QD =  S  S  QE S = ECLOSE(S)  qD = ECLOSE(q0) FD = SS QD  S  FE    对 S  QD 和 a   , 令 S = { p1 , p2 ,  , pk }， 并设  E ( pi , a ) = { r1 , r2 ,  , rm }， 则 D ( S , a ) =  ECLOSE( rj ) . - 设 | QE |=n, 该构造过程复杂度为O(n32n).但实际运行时 间的上界可以是O(n3s)，其中 s 为 DFA 实际状态数。i = 1k j = 1m几个转换算法的复杂度（选讲）

##### 关键点

- 要点: 第124页内容 从  - NFA 构造 DFA - 回顾：设  - NFA E = (QE, , E , q0 , FE) , 构造 D = (QD, , D , qD , FD ) , 其中 QD =  S  S  QE S = ECLOSE(S)  qD = ECLOSE(q0) FD = SS QD  S  FE    对 S  QD 和 a   

#### 第125页内容
*来源: 第125页*

从 DFA 构造正规表达式 - 回顾： (路径迭代法) (1) 将 DFA D 的状态集用{1, 2, … , n}表达，且初态为1; (2) 对所有i, j, k = 1, 2, … , n ，迭代计算R(ikj)； (3) 将所有 R(1nj)（j 为任一终态）相“” - 该构造过程复杂度为O(n34n)（考虑表达式的大小） - 采用状态消去法具有同样的复杂度几个转换算法的复杂度（选讲）

##### 关键点

- 要点: 第125页内容 从 DFA 构造正规表达式 - 回顾： (路径迭代法) (1) 将 DFA D 的状态集用{1, 2, … , n}表达，且初态为1; (2) 对所有i, j, k = 1, 2, … , n ，迭代计算R(ikj)； (3) 将所有 R(1nj)（j 为任一终态）相“” - 该构造过程复杂度为O(n34n)（考虑表达式的大小） - 采用状态消去法具有同样的复杂度几个转换算法的复

#### 第126页内容
*来源: 第126页*

从正规表达式构造 - NFA - 回顾： 归纳于正规表达式的结构，或通过构造一棵表达式 树，然后根据归纳构造规则得到 - NFA；每一结 点上的工作只是增加不超过两个新的状态，以及不 超过四条新的弧. - 该构造过程复杂度为O(n), 这里 n 为正规表达式的 大小.几个转换算法的复杂度（选讲）

##### 关键点

- 要点: 第126页内容 从正规表达式构造 - NFA - 回顾： 归纳于正规表达式的结构，或通过构造一棵表达式 树，然后根据归纳构造规则得到 - NFA；每一结 点上的工作只是增加不超过两个新的状态，以及不 超过四条新的弧. - 该构造过程复杂度为O(n), 这里 n 为正规表达式的 大小.几个转换算法的复杂度（选讲）

---
